* 왜 언리얼은 엔비디아의 PhysX와 자체 물리엔진인 카오스 엔진 두 개를 모두 사용하는가? (UE4)  
https://forums.unrealengine.com/t/why-ue5-both-have-physx-and-chaos/601599/3  

* Physics tick rate matters a lot  
시작에 앞서, 지금 언급할 방식은 언리얼 엔진이 사용하도록 의도된 방식이 아님을 인지하자.  
그러나 물리연산이 중요한 게임(레이싱게임 등)에서는 사용될 수 밖에 없는 경우가 있다는 것또한 인지하자.  

언리얼의 Physics 시뮬레이션은 기본값으로 매 frame(하드웨어 dependent, 일반적으로 구동중인 하드웨어에서 가능한 최대 속도로 작동, 이걸 수동으로 리밋 걸 수도 있음)마다 계산되어 업데이트되도록 설정되어있다. framerate에 따라 렌더링 속도가 달라지는 것은 일반적으로 게임을 하는 데 큰 지장이 없는 것에 반해, 물리연산의 경우 rate에 따라 그 결과가 달라질 수 있기 떄문에 이를 반드시 고정시켜주어야 한다. 탄성과 관련된 Physics spring의 경우 특히 이러한 현상이 더 심하다.  
  
Nvidia는 때문에 Fixed tick rate를 권장한다. 즉 렌더링 rate와 무관하게 fixed tick rate를 지정하도록 권장한다. 그러나 에픽에서는 언리얼에 physics tick의 min값을 설정할 수 있게만 해두었지, 자체적으로 fixed rate를 지원해주지 않는다.  
  
물론 min값만 사용해도 큰 오차가 발생하지 않는 경우들도 많지만, 언리얼이 Physics를 처리하는 방식 특성상 렌더링 framerate가 높아지면 physics tick rate도 덩달아 높아져 불필요하게 물리연산을 자주 하게 되는 일이 발생해 성능 저하로까지 이어질 수 있다. (참고: 그러나 이러한 성능저하 영향은 크지 않긴 하다. 우리가 fixed rate를 만드려는 가장 큰 이유는 성능이 아니라 서로 다른 rate일때의 계산 오차임을 인지하자)  
  
자, 이렇게 physics fixed rate의 중요성을 이해했다. 그러나 문제는 여전히 남아있다.  
가장 큰 문제는 당장 언리얼 c++객체의 tick 함수가 physics와 동일한 빈도로 동작하지 않는다는 점이다. tick()은 per game frame마다 호출되므로 우리는 이거 말고 per physics substep마다 작동하는 별도의 함수가 필요하다.  
  
바로 여기서 아주 중요한 개념 하나가 더 등장하는데, 언리얼의 물리연산은 게임 스레드 이외의 별도 스레드에서 병렬적으로 동작한다! 즉 Physics 관련 코드를 건드릴 때는 항상 이게 멀티스레드에서 동작중이라는 사실을 인지하고 작성해야 한다.  
  
이 방식의 구현 방법에 대해서는 여기서는 언급하지 않는다. UEPro75 - I am Vehicle 참조. 대략적으로만 설명하면 엔비디아의 PhysX를 사용하며, 언리얼의 피직스 시스템을 직접 호출해 물리 관련 함수들을 직접 싹다 재구현하고 게임 내의 모든 물리 처리는 이렇게 재구현된 함수만을 사용해 연산하는 형태로 구현한다.  

(주석:  
물리엔진이 멀티스레드에서 작동하는 것에 대한 문제 방지는 어떤 식으로 처리되나?  
다행히도 일일히 락을 걸고 하지는 않고, 언리얼의 피직스 시스템의 API 중 FPhysicsCommand::ExecuteRead(), ...Write()가 있는데 해당 함수에 람다 함수를 인자로 넘겨주는 방식으로 처리한다. 그냥 쉽게 말해 락을 크게 신경쓰지 않게 해주는 API를 언리얼에서 제공한다.  
)  







